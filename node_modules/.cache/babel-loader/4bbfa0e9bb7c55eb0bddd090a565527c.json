{"ast":null,"code":"'use strict';\n\nconst cbor = require('borc');\n\nconst multihashing = require('multihashing-async');\n\nconst CID = require('cids');\n\nconst isCircular = require('is-circular');\n\nconst resolver = require('./resolver'); // https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\n\n\nconst CID_CBOR_TAG = 42;\n\nfunction tagCID(cid) {\n  if (typeof cid === 'string') {\n    cid = new CID(cid).buffer;\n  } else if (CID.isCID(cid)) {\n    cid = cid.buffer;\n  }\n\n  return new cbor.Tagged(CID_CBOR_TAG, Buffer.concat([Buffer.from('00', 'hex'), // thanks jdag\n  cid]));\n}\n\nconst decoder = new cbor.Decoder({\n  tags: {\n    [CID_CBOR_TAG]: val => {\n      // remove that 0\n      val = val.slice(1);\n      return new CID(val);\n    }\n  }\n});\n\nfunction replaceCIDbyTAG(dagNode) {\n  let circular;\n\n  try {\n    circular = isCircular(dagNode);\n  } catch (e) {\n    circular = false;\n  }\n\n  if (circular) {\n    throw new Error('The object passed has circular references');\n  }\n\n  function transform(obj) {\n    if (!obj || Buffer.isBuffer(obj) || typeof obj === 'string') {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(transform);\n    }\n\n    if (CID.isCID(obj)) {\n      return tagCID(obj);\n    }\n\n    const keys = Object.keys(obj);\n\n    if (keys.length === 1 && keys[0] === '/') {\n      // Multiaddr encoding\n      // if (typeof link === 'string' && isMultiaddr(link)) {\n      //  link = new Multiaddr(link).buffer\n      // }\n      return tagCID(obj['/']);\n    } else if (keys.length > 0) {\n      // Recursive transform\n      const out = {};\n      keys.forEach(key => {\n        if (typeof obj[key] === 'object') {\n          out[key] = transform(obj[key]);\n        } else {\n          out[key] = obj[key];\n        }\n      });\n      return out;\n    } else {\n      return obj;\n    }\n  }\n\n  return transform(dagNode);\n}\n\nexports = module.exports;\n\nexports.serialize = (dagNode, callback) => {\n  let serialized;\n\n  try {\n    const dagNodeTagged = replaceCIDbyTAG(dagNode);\n    serialized = cbor.encode(dagNodeTagged);\n  } catch (err) {\n    return setImmediate(() => callback(err));\n  }\n\n  setImmediate(() => callback(null, serialized));\n};\n\nexports.deserialize = (data, callback) => {\n  let deserialized;\n\n  try {\n    deserialized = decoder.decodeFirst(data);\n  } catch (err) {\n    return setImmediate(() => callback(err));\n  }\n\n  setImmediate(() => callback(null, deserialized));\n};\n/**\n * @callback CidCallback\n * @param {?Error} error - Error if getting the CID failed\n * @param {?CID} cid - CID if call was successful\n */\n\n/**\n * Get the CID of the DAG-Node.\n *\n * @param {Object} dagNode - Internal representation\n * @param {Object} [options] - Options to create the CID\n * @param {number} [options.version=1] - CID version number\n * @param {string} [options.hashAlg] - Defaults to hashAlg for the resolver\n * @param {number} [options.hashLen] - Optionally trim the digest to this length\n * @param {CidCallback} callback - Callback that handles the return value\n * @returns {void}\n */\n\n\nexports.cid = (dagNode, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  const hashAlg = options.hashAlg || resolver.defaultHashAlg;\n  const hashLen = options.hashLen;\n  const version = typeof options.version === 'undefined' ? 1 : options.version;\n  exports.serialize(dagNode, (err, serialized) => {\n    if (err) return callback(err);\n    multihashing(serialized, hashAlg, hashLen, (err, mh) => {\n      if (err) return callback(err);\n      callback(null, new CID(version, resolver.multicodec, mh));\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"script"}