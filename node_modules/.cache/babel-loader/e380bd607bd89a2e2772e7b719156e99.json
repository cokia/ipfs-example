{"ast":null,"code":"// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nconst Buffer = require('safe-buffer').Buffer;\n\nmodule.exports = function base(ALPHABET) {\n  if (ALPHABET.length >= 255) throw new TypeError('Alphabet too long');\n  const BASE_MAP = new Uint8Array(256);\n  BASE_MAP.fill(255);\n\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i);\n    const xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) throw new TypeError(x + ' is ambiguous');\n    BASE_MAP[xc] = i;\n  }\n\n  const BASE = ALPHABET.length;\n  const LEADER = ALPHABET.charAt(0);\n  const FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n\n  const iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n\n  function encode(source) {\n    if (!Buffer.isBuffer(source)) throw new TypeError('Expected Buffer');\n    if (source.length === 0) return ''; // Skip & count leading zeroes.\n\n    let zeroes = 0;\n    let length = 0;\n    let pbegin = 0;\n    const pend = source.length;\n\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    } // Allocate enough space in big-endian base58 representation.\n\n\n    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    const b58 = new Uint8Array(size); // Process the bytes.\n\n    while (pbegin !== pend) {\n      let carry = source[pbegin]; // Apply \"b58 = b58 * 256 + ch\".\n\n      let i = 0;\n\n      for (let it = size - 1; (carry !== 0 || i < length) && it !== -1; it--, i++) {\n        carry += 256 * b58[it] >>> 0;\n        b58[it] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n\n      if (carry !== 0) throw new Error('Non-zero carry');\n      length = i;\n      pbegin++;\n    } // Skip leading zeroes in base58 result.\n\n\n    let it = size - length;\n\n    while (it !== size && b58[it] === 0) {\n      it++;\n    } // Translate the result into a string.\n\n\n    let str = LEADER.repeat(zeroes);\n\n    for (; it < size; ++it) str += ALPHABET.charAt(b58[it]);\n\n    return str;\n  }\n\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') throw new TypeError('Expected String');\n    if (source.length === 0) return Buffer.alloc(0);\n    let psz = 0; // Skip leading spaces.\n\n    if (source[psz] === ' ') return; // Skip and count leading '1's.\n\n    let zeroes = 0;\n    let length = 0;\n\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    } // Allocate enough space in big-endian base256 representation.\n\n\n    const size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.\n\n    const b256 = new Uint8Array(size); // Process the characters.\n\n    while (source[psz]) {\n      // Decode character\n      let carry = BASE_MAP[source.charCodeAt(psz)]; // Invalid character\n\n      if (carry === 255) return;\n      let i = 0;\n\n      for (let it = size - 1; (carry !== 0 || i < length) && it !== -1; it--, i++) {\n        carry += BASE * b256[it] >>> 0;\n        b256[it] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n\n      if (carry !== 0) throw new Error('Non-zero carry');\n      length = i;\n      psz++;\n    } // Skip trailing spaces.\n\n\n    if (source[psz] === ' ') return; // Skip leading zeroes in b256.\n\n    let it = size - length;\n\n    while (it !== size && b256[it] === 0) {\n      it++;\n    }\n\n    const vch = Buffer.allocUnsafe(zeroes + (size - it));\n    vch.fill(0x00, 0, zeroes);\n    let j = zeroes;\n\n    while (it !== size) {\n      vch[j++] = b256[it++];\n    }\n\n    return vch;\n  }\n\n  function decode(string) {\n    const buffer = decodeUnsafe(string);\n    if (buffer) return buffer;\n    throw new Error('Non-base' + BASE + ' character');\n  }\n\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n};","map":null,"metadata":{},"sourceType":"script"}