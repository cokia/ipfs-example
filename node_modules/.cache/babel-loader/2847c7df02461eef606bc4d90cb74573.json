{"ast":null,"code":"'use strict';\n\nconst webcrypto = require('../webcrypto.js')();\n\nconst nodeify = require('../nodeify');\n\nconst BN = require('asn1.js').bignum;\n\nconst util = require('../util');\n\nconst toBase64 = util.toBase64;\nconst toBn = util.toBn;\nconst bits = {\n  'P-256': 256,\n  'P-384': 384,\n  'P-521': 521\n};\n\nexports.generateEphmeralKeyPair = function (curve, callback) {\n  nodeify(webcrypto.subtle.generateKey({\n    name: 'ECDH',\n    namedCurve: curve\n  }, true, ['deriveBits']).then(pair => {\n    // forcePrivate is used for testing only\n    const genSharedKey = (theirPub, forcePrivate, cb) => {\n      if (typeof forcePrivate === 'function') {\n        cb = forcePrivate;\n        forcePrivate = undefined;\n      }\n\n      let privateKey;\n\n      if (forcePrivate) {\n        privateKey = webcrypto.subtle.importKey('jwk', unmarshalPrivateKey(curve, forcePrivate), {\n          name: 'ECDH',\n          namedCurve: curve\n        }, false, ['deriveBits']);\n      } else {\n        privateKey = Promise.resolve(pair.privateKey);\n      }\n\n      const keys = Promise.all([webcrypto.subtle.importKey('jwk', unmarshalPublicKey(curve, theirPub), {\n        name: 'ECDH',\n        namedCurve: curve\n      }, false, []), privateKey]);\n      nodeify(keys.then(keys => webcrypto.subtle.deriveBits({\n        name: 'ECDH',\n        namedCurve: curve,\n        public: keys[0]\n      }, keys[1], bits[curve])).then(bits => Buffer.from(bits)), cb);\n    };\n\n    return webcrypto.subtle.exportKey('jwk', pair.publicKey).then(publicKey => {\n      return {\n        key: marshalPublicKey(publicKey),\n        genSharedKey\n      };\n    });\n  }), callback);\n};\n\nconst curveLengths = {\n  'P-256': 32,\n  'P-384': 48,\n  'P-521': 66 // Marshal converts a jwk encodec ECDH public key into the\n  // form specified in section 4.3.6 of ANSI X9.62. (This is the format\n  // go-ipfs uses)\n\n};\n\nfunction marshalPublicKey(jwk) {\n  const byteLen = curveLengths[jwk.crv];\n  return Buffer.concat([Buffer.from([4]), // uncompressed point\n  toBn(jwk.x).toArrayLike(Buffer, 'be', byteLen), toBn(jwk.y).toArrayLike(Buffer, 'be', byteLen)], 1 + byteLen * 2);\n} // Unmarshal converts a point, serialized by Marshal, into an jwk encoded key\n\n\nfunction unmarshalPublicKey(curve, key) {\n  const byteLen = curveLengths[curve];\n\n  if (!key.slice(0, 1).equals(Buffer.from([4]))) {\n    throw new Error('Invalid key format');\n  }\n\n  const x = new BN(key.slice(1, byteLen + 1));\n  const y = new BN(key.slice(1 + byteLen));\n  return {\n    kty: 'EC',\n    crv: curve,\n    x: toBase64(x, byteLen),\n    y: toBase64(y, byteLen),\n    ext: true\n  };\n}\n\nfunction unmarshalPrivateKey(curve, key) {\n  const result = unmarshalPublicKey(curve, key.public);\n  result.d = toBase64(new BN(key.private));\n  return result;\n}","map":null,"metadata":{},"sourceType":"script"}