{"ast":null,"code":"'use strict';\n\nconst Transform = require('stream').Transform;\n\nconst isNode = require('detect-node');\n\nconst isSource = require('is-pull-stream').isSource;\n\nconst toStream = require('pull-stream-to-stream');\n\nconst PADDING = '--';\nconst NEW_LINE = '\\r\\n';\nconst NEW_LINE_BUFFER = Buffer.from(NEW_LINE);\n\nclass Multipart extends Transform {\n  constructor(options) {\n    super(Object.assign({}, options, {\n      objectMode: true,\n      highWaterMark: 1\n    }));\n    this._boundary = this._generateBoundary();\n    this._files = [];\n    this._draining = false;\n  }\n\n  _flush() {\n    this.push(Buffer.from(PADDING + this._boundary + PADDING + NEW_LINE));\n    this.push(null);\n  }\n\n  _generateBoundary() {\n    var boundary = '--------------------------';\n\n    for (var i = 0; i < 24; i++) {\n      boundary += Math.floor(Math.random() * 10).toString(16);\n    }\n\n    return boundary;\n  }\n\n  _transform(file, encoding, callback) {\n    if (Buffer.isBuffer(file)) {\n      this.push(file);\n      return callback(); // early\n    } // not a buffer, must be a file\n\n\n    this._files.push(file);\n\n    this._maybeDrain(callback);\n  }\n\n  _maybeDrain(callback) {\n    if (!this._draining) {\n      if (this._files.length) {\n        this._draining = true;\n\n        const file = this._files.shift();\n\n        this._pushFile(file, err => {\n          this._draining = false;\n\n          if (err) {\n            this.emit('error', err);\n          } else {\n            this._maybeDrain(callback);\n          }\n        });\n      } else {\n        this.emit('drained all files');\n        callback();\n      }\n    } else {\n      this.once('drained all files', callback);\n    }\n  }\n\n  _pushFile(file, callback) {\n    const leading = this._leading(file.headers || {});\n\n    this.push(leading);\n    let content = file.content || Buffer.alloc(0);\n\n    if (Buffer.isBuffer(content)) {\n      this.push(content);\n      this.push(NEW_LINE_BUFFER);\n      return callback(); // early\n    }\n\n    if (isSource(content)) {\n      content = toStream.source(content);\n    } // From now on we assume content is a stream\n\n\n    content.once('error', this.emit.bind(this, 'error'));\n    content.once('end', () => {\n      this.push(NEW_LINE_BUFFER);\n      callback(); // TODO: backpressure!!! wait once self is drained so we can proceed\n      // This does not work\n      // this.once('drain', () => {\n      //   callback()\n      // })\n    });\n    content.on('data', data => {\n      const drained = this.push(data); // Only do the drain dance on Node.js.\n      // In browserland, the underlying stream\n      // does NOT drain because the request is only sent\n      // once this stream ends.\n\n      if (!drained && isNode) {\n        content.pause();\n        this.once('drain', () => content.resume());\n      }\n    });\n  }\n\n  _leading(headers) {\n    var leading = [PADDING + this._boundary];\n    Object.keys(headers).forEach(header => {\n      leading.push(header + ': ' + headers[header]);\n    });\n    leading.push('');\n    leading.push('');\n    const leadingStr = leading.join(NEW_LINE);\n    return Buffer.from(leadingStr);\n  }\n\n}\n\nmodule.exports = Multipart;","map":null,"metadata":{},"sourceType":"script"}