{"ast":null,"code":"'use strict';\n\nconst _require = require('iso-url'),\n      URL = _require.URL;\n\nconst Bignumber = require('bignumber.js');\n\nconst utils = require('./utils');\n\nconst constants = require('./constants');\n\nconst MT = constants.MT;\nconst NUMBYTES = constants.NUMBYTES;\nconst SHIFT32 = constants.SHIFT32;\nconst SYMS = constants.SYMS;\nconst TAG = constants.TAG;\nconst HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;\nconst FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;\nconst DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;\nconst TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;\nconst FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;\nconst UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;\nconst NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;\nconst MAXINT_BN = new Bignumber('0x20000000000000');\nconst BUF_NAN = Buffer.from('f97e00', 'hex');\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex');\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex');\n\nfunction toType(obj) {\n  // [object Type]\n  // --------8---1\n  return {}.toString.call(obj).slice(8, -1);\n}\n/**\n * Transform JavaScript values into CBOR bytes\n *\n */\n\n\nclass Encoder {\n  /**\n   * @param {Object} [options={}]\n   * @param {function(Buffer)} options.stream\n   */\n  constructor(options) {\n    options = options || {};\n    this.streaming = typeof options.stream === 'function';\n    this.onData = options.stream;\n    this.semanticTypes = [[URL, this._pushUrl], [Bignumber, this._pushBigNumber]];\n    const addTypes = options.genTypes || [];\n    const len = addTypes.length;\n\n    for (let i = 0; i < len; i++) {\n      this.addSemanticType(addTypes[i][0], addTypes[i][1]);\n    }\n\n    this._reset();\n  }\n\n  addSemanticType(type, fun) {\n    const len = this.semanticTypes.length;\n\n    for (let i = 0; i < len; i++) {\n      const typ = this.semanticTypes[i][0];\n\n      if (typ === type) {\n        const old = this.semanticTypes[i][1];\n        this.semanticTypes[i][1] = fun;\n        return old;\n      }\n    }\n\n    this.semanticTypes.push([type, fun]);\n    return null;\n  }\n\n  push(val) {\n    if (!val) {\n      return true;\n    }\n\n    this.result[this.offset] = val;\n    this.resultMethod[this.offset] = 0;\n    this.resultLength[this.offset] = val.length;\n    this.offset++;\n\n    if (this.streaming) {\n      this.onData(this.finalize());\n    }\n\n    return true;\n  }\n\n  pushWrite(val, method, len) {\n    this.result[this.offset] = val;\n    this.resultMethod[this.offset] = method;\n    this.resultLength[this.offset] = len;\n    this.offset++;\n\n    if (this.streaming) {\n      this.onData(this.finalize());\n    }\n\n    return true;\n  }\n\n  _pushUInt8(val) {\n    return this.pushWrite(val, 1, 1);\n  }\n\n  _pushUInt16BE(val) {\n    return this.pushWrite(val, 2, 2);\n  }\n\n  _pushUInt32BE(val) {\n    return this.pushWrite(val, 3, 4);\n  }\n\n  _pushDoubleBE(val) {\n    return this.pushWrite(val, 4, 8);\n  }\n\n  _pushNaN() {\n    return this.push(BUF_NAN);\n  }\n\n  _pushInfinity(obj) {\n    const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;\n    return this.push(half);\n  }\n\n  _pushFloat(obj) {\n    const b2 = Buffer.allocUnsafe(2);\n\n    if (utils.writeHalf(b2, obj)) {\n      if (utils.parseHalf(b2) === obj) {\n        return this._pushUInt8(HALF) && this.push(b2);\n      }\n    }\n\n    const b4 = Buffer.allocUnsafe(4);\n    b4.writeFloatBE(obj, 0);\n\n    if (b4.readFloatBE(0) === obj) {\n      return this._pushUInt8(FLOAT) && this.push(b4);\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);\n  }\n\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5;\n\n    if (obj < 24) {\n      return this._pushUInt8(m | obj);\n    }\n\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);\n    }\n\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);\n    }\n\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);\n    }\n\n    if (obj <= Number.MAX_SAFE_INTEGER) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);\n    }\n\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig);\n    }\n\n    return this._pushFloat(obj);\n  }\n\n  _pushIntNum(obj) {\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj);\n    } else {\n      return this._pushInt(obj, MT.POS_INT);\n    }\n  }\n\n  _pushNumber(obj) {\n    switch (false) {\n      case obj === obj:\n        // eslint-disable-line\n        return this._pushNaN(obj);\n\n      case isFinite(obj):\n        return this._pushInfinity(obj);\n\n      case obj % 1 !== 0:\n        return this._pushIntNum(obj);\n\n      default:\n        return this._pushFloat(obj);\n    }\n  }\n\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8');\n    return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len);\n  }\n\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE);\n  }\n\n  _pushUndefined(obj) {\n    return this._pushUInt8(UNDEFINED);\n  }\n\n  _pushArray(gen, obj) {\n    const len = obj.length;\n\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG);\n  }\n\n  _pushDate(gen, obj) {\n    // Round date, to get seconds since 1970-01-01 00:00:00 as defined in\n    // Sec. 2.4.1 and get a possibly more compact encoding. Note that it is\n    // still allowed to encode fractions of seconds which can be achieved by\n    // changing overwriting the encode function for Date objects.\n    return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1000));\n  }\n\n  _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);\n  }\n\n  _pushNoFilter(gen, obj) {\n    return gen._pushBuffer(gen, obj.slice());\n  }\n\n  _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);\n  }\n\n  _pushSet(gen, obj) {\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false;\n    }\n\n    for (let x of obj) {\n      if (!gen.pushAny(x)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _pushUrl(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());\n  }\n\n  _pushBigint(obj) {\n    let tag = TAG.POS_BIGINT;\n\n    if (obj.isNegative()) {\n      obj = obj.negated().minus(1);\n      tag = TAG.NEG_BIGINT;\n    }\n\n    let str = obj.toString(16);\n\n    if (str.length % 2) {\n      str = '0' + str;\n    }\n\n    const buf = Buffer.from(str, 'hex');\n    return this._pushTag(tag) && this._pushBuffer(this, buf);\n  }\n\n  _pushBigNumber(gen, obj) {\n    if (obj.isNaN()) {\n      return gen._pushNaN();\n    }\n\n    if (!obj.isFinite()) {\n      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);\n    }\n\n    if (obj.isInteger()) {\n      return gen._pushBigint(obj);\n    }\n\n    if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {\n      return false;\n    }\n\n    const dec = obj.decimalPlaces();\n    const slide = obj.multipliedBy(new Bignumber(10).pow(dec));\n\n    if (!gen._pushIntNum(-dec)) {\n      return false;\n    }\n\n    if (slide.abs().isLessThan(MAXINT_BN)) {\n      return gen._pushIntNum(slide.toNumber());\n    } else {\n      return gen._pushBigint(slide);\n    }\n  }\n\n  _pushMap(gen, obj) {\n    if (!gen._pushInt(obj.size, MT.MAP)) {\n      return false;\n    }\n\n    return this._pushRawMap(obj.size, Array.from(obj));\n  }\n\n  _pushObject(obj) {\n    if (!obj) {\n      return this._pushUInt8(NULL);\n    }\n\n    var len = this.semanticTypes.length;\n\n    for (var i = 0; i < len; i++) {\n      if (obj instanceof this.semanticTypes[i][0]) {\n        return this.semanticTypes[i][1].call(obj, this, obj);\n      }\n    }\n\n    var f = obj.encodeCBOR;\n\n    if (typeof f === 'function') {\n      return f.call(obj, this);\n    }\n\n    var keys = Object.keys(obj);\n    var keyLength = keys.length;\n\n    if (!this._pushInt(keyLength, MT.MAP)) {\n      return false;\n    }\n\n    return this._pushRawMap(keyLength, keys.map(k => [k, obj[k]]));\n  }\n\n  _pushRawMap(len, map) {\n    // Sort keys for canoncialization\n    // 1. encode key\n    // 2. shorter key comes before longer key\n    // 3. same length keys are sorted with lower\n    //    byte value before higher\n    map = map.map(function (a) {\n      a[0] = Encoder.encode(a[0]);\n      return a;\n    }).sort(utils.keySorter);\n\n    for (var j = 0; j < len; j++) {\n      if (!this.push(map[j][0])) {\n        return false;\n      }\n\n      if (!this.pushAny(map[j][1])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Alias for `.pushAny`\n   *\n   * @param {*} obj\n   * @returns {boolean} true on success\n   */\n\n\n  write(obj) {\n    return this.pushAny(obj);\n  }\n  /**\n   * Push any supported type onto the encoded stream\n   *\n   * @param {any} obj\n   * @returns {boolean} true on success\n   */\n\n\n  pushAny(obj) {\n    var typ = toType(obj);\n\n    switch (typ) {\n      case 'Number':\n        return this._pushNumber(obj);\n\n      case 'String':\n        return this._pushString(obj);\n\n      case 'Boolean':\n        return this._pushBoolean(obj);\n\n      case 'Object':\n        return this._pushObject(obj);\n\n      case 'Array':\n        return this._pushArray(this, obj);\n\n      case 'Uint8Array':\n        return this._pushBuffer(this, Buffer.isBuffer(obj) ? obj : Buffer.from(obj));\n\n      case 'Null':\n        return this._pushUInt8(NULL);\n\n      case 'Undefined':\n        return this._pushUndefined(obj);\n\n      case 'Map':\n        return this._pushMap(this, obj);\n\n      case 'Set':\n        return this._pushSet(this, obj);\n\n      case 'URL':\n        return this._pushUrl(this, obj);\n\n      case 'BigNumber':\n        return this._pushBigNumber(this, obj);\n\n      case 'Date':\n        return this._pushDate(this, obj);\n\n      case 'RegExp':\n        return this._pushRegexp(this, obj);\n\n      case 'Symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushObject(null);\n\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(void 0);\n          // TODO: Add pluggable support for other symbols\n\n          default:\n            throw new Error('Unknown symbol: ' + obj.toString());\n        }\n\n      default:\n        throw new Error('Unknown type: ' + typeof obj + ', ' + (obj ? obj.toString() : ''));\n    }\n  }\n\n  finalize() {\n    if (this.offset === 0) {\n      return null;\n    }\n\n    var result = this.result;\n    var resultLength = this.resultLength;\n    var resultMethod = this.resultMethod;\n    var offset = this.offset; // Determine the size of the buffer\n\n    var size = 0;\n    var i = 0;\n\n    for (; i < offset; i++) {\n      size += resultLength[i];\n    }\n\n    var res = Buffer.allocUnsafe(size);\n    var index = 0;\n    var length = 0; // Write the content into the result buffer\n\n    for (i = 0; i < offset; i++) {\n      length = resultLength[i];\n\n      switch (resultMethod[i]) {\n        case 0:\n          result[i].copy(res, index);\n          break;\n\n        case 1:\n          res.writeUInt8(result[i], index, true);\n          break;\n\n        case 2:\n          res.writeUInt16BE(result[i], index, true);\n          break;\n\n        case 3:\n          res.writeUInt32BE(result[i], index, true);\n          break;\n\n        case 4:\n          res.writeDoubleBE(result[i], index, true);\n          break;\n\n        case 5:\n          res.write(result[i], index, length, 'utf8');\n          break;\n\n        default:\n          throw new Error('unkown method');\n      }\n\n      index += length;\n    }\n\n    var tmp = res;\n\n    this._reset();\n\n    return tmp;\n  }\n\n  _reset() {\n    this.result = [];\n    this.resultMethod = [];\n    this.resultLength = [];\n    this.offset = 0;\n  }\n  /**\n   * Encode the given value\n   * @param {*} o\n   * @returns {Buffer}\n   */\n\n\n  static encode(o) {\n    const enc = new Encoder();\n    const ret = enc.pushAny(o);\n\n    if (!ret) {\n      throw new Error('Failed to encode input');\n    }\n\n    return enc.finalize();\n  }\n\n}\n\nmodule.exports = Encoder;","map":null,"metadata":{},"sourceType":"script"}