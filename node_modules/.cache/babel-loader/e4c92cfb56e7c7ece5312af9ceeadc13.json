{"ast":null,"code":"'use strict';\n\nconst ensureMultiaddr = require('./utils').ensureMultiaddr;\n\nconst uniqBy = require('lodash.uniqby'); // Because JavaScript doesn't let you overload the compare in Set()..\n\n\nclass MultiaddrSet {\n  constructor(multiaddrs) {\n    this._multiaddrs = multiaddrs || [];\n    this._observedMultiaddrs = [];\n  }\n\n  add(ma) {\n    ma = ensureMultiaddr(ma);\n\n    if (!this.has(ma)) {\n      this._multiaddrs.push(ma);\n    }\n  } // addSafe - prevent multiaddr explosionâ„¢\n  // Multiaddr explosion is when you dial to a bunch of nodes and every node\n  // gives you a different observed address and you start storing them all to\n  // share with other peers. This seems like a good idea until you realize that\n  // most of those addresses are unique to the subnet that peer is in and so,\n  // they are completely worthless for all the other peers. This method is\n  // exclusively used by identify.\n\n\n  addSafe(ma) {\n    ma = ensureMultiaddr(ma);\n\n    const check = this._observedMultiaddrs.some((m, i) => {\n      if (m.equals(ma)) {\n        this.add(ma);\n\n        this._observedMultiaddrs.splice(i, 1);\n\n        return true;\n      }\n    });\n\n    if (!check) {\n      this._observedMultiaddrs.push(ma);\n    }\n  }\n\n  toArray() {\n    return this._multiaddrs.slice();\n  }\n\n  get size() {\n    return this._multiaddrs.length;\n  }\n\n  forEach(fn) {\n    return this._multiaddrs.forEach(fn);\n  }\n\n  filterBy(maFmt) {\n    if (typeof maFmt !== 'object' || typeof maFmt.matches !== 'function' || typeof maFmt.partialMatch !== 'function' || typeof maFmt.toString !== 'function') return [];\n    return this._multiaddrs.filter(ma => maFmt.matches(ma));\n  }\n\n  has(ma) {\n    ma = ensureMultiaddr(ma);\n    return this._multiaddrs.some(m => m.equals(ma));\n  }\n\n  delete(ma) {\n    ma = ensureMultiaddr(ma);\n\n    this._multiaddrs.some((m, i) => {\n      if (m.equals(ma)) {\n        this._multiaddrs.splice(i, 1);\n\n        return true;\n      }\n    });\n  } // replaces selected existing multiaddrs with new ones\n\n\n  replace(existing, fresh) {\n    if (!Array.isArray(existing)) {\n      existing = [existing];\n    }\n\n    if (!Array.isArray(fresh)) {\n      fresh = [fresh];\n    }\n\n    existing.forEach(m => this.delete(m));\n    fresh.forEach(m => this.add(m));\n  }\n\n  clear() {\n    this._multiaddrs = [];\n  } // this only really helps make ip6 and ip4 multiaddrs distinct if they are\n  // different\n  // TODO this is not an ideal solution, probably this code should just be\n  // in libp2p-tcp\n\n\n  distinct() {\n    return uniqBy(this._multiaddrs, ma => {\n      return [ma.toOptions().port, ma.toOptions().transport].join();\n    });\n  }\n\n}\n\nmodule.exports = MultiaddrSet;","map":null,"metadata":{},"sourceType":"script"}