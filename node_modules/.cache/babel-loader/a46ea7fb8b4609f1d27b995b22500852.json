{"ast":null,"code":"'use strict';\n\nconst waterfall = require('async/waterfall');\n\nconst CID = require('cids');\n\nconst util = require('./util');\n\nexports = module.exports;\nexports.multicodec = 'dag-pb';\nexports.defaultHashAlg = 'sha2-256';\n/*\n * resolve: receives a path and a binary blob and returns the value on path,\n * throw if not possible. `binaryBlob` is the ProtocolBuffer encoded data.\n */\n\nexports.resolve = (binaryBlob, path, callback) => {\n  waterfall([cb => util.deserialize(binaryBlob, cb), (node, cb) => {\n    // Return the deserialized block if no path is given\n    if (!path) {\n      return callback(null, {\n        value: node,\n        remainderPath: ''\n      });\n    }\n\n    const split = path.split('/');\n\n    if (split[0] === 'Links') {\n      let remainderPath = ''; // all links\n\n      if (!split[1]) {\n        return cb(null, {\n          value: node.links.map(l => l.toJSON()),\n          remainderPath: ''\n        });\n      } // select one link\n\n\n      const values = {}; // populate both index number and name to enable both cases\n      // for the resolver\n\n      node.links.forEach((l, i) => {\n        const link = l.toJSON();\n        values[i] = values[link.name] = {\n          hash: link.multihash,\n          name: link.name,\n          size: link.size\n        };\n      });\n      let value = values[split[1]]; // if remainderPath exists, value needs to be CID\n\n      if (split[2] === 'Hash') {\n        value = {\n          '/': value.hash\n        };\n      } else if (split[2] === 'Tsize') {\n        value = value.size;\n      } else if (split[2] === 'Name') {\n        value = value.name;\n      }\n\n      remainderPath = split.slice(3).join('/');\n      cb(null, {\n        value: value,\n        remainderPath: remainderPath\n      });\n    } else if (split[0] === 'Data') {\n      cb(null, {\n        value: node.data,\n        remainderPath: ''\n      });\n    } else {\n      // If split[0] is not 'Data' or 'Links' then we might be trying to refer\n      // to a named link from the Links array. This is because go-ipfs and\n      // js-ipfs have historically supported the ability to do\n      // `ipfs dag get CID/a` where a is a named link in a dag-pb.\n      const values = {};\n      node.links.forEach((l, i) => {\n        const link = l.toJSON();\n        values[link.name] = {\n          hash: link.multihash,\n          name: link.name,\n          size: link.size\n        };\n      });\n      const value = values[split[0]];\n\n      if (value) {\n        return cb(null, {\n          value: {\n            '/': value.hash\n          },\n          remainderPath: split.slice(1).join('/')\n        });\n      }\n\n      cb(new Error('path not available'));\n    }\n  }], callback);\n};\n/*\n * tree: returns a flattened array with paths: values of the project. options\n * is an object that can carry several options (i.e. nestness)\n */\n\n\nexports.tree = (binaryBlob, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  util.deserialize(binaryBlob, (err, node) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const paths = [];\n    paths.push('Links');\n    node.links.forEach((link, i) => {\n      paths.push(\"Links/\".concat(i, \"/Name\"));\n      paths.push(\"Links/\".concat(i, \"/Tsize\"));\n      paths.push(\"Links/\".concat(i, \"/Hash\"));\n    });\n    paths.push('Data');\n    callback(null, paths);\n  });\n};\n/*\n * isLink: returns the Link if a given path in a binary blob is a Link,\n * false otherwise\n */\n\n\nexports.isLink = (binaryBlob, path, callback) => {\n  exports.resolve(binaryBlob, path, (err, result) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (result.remainderPath.length > 0) {\n      return callback(new Error('path out of scope'));\n    }\n\n    if (typeof result.value === 'object' && result.value['/']) {\n      let valid;\n\n      try {\n        valid = CID.isCID(new CID(result.value['/']));\n      } catch (err) {\n        valid = false;\n      }\n\n      if (valid) {\n        return callback(null, result.value);\n      }\n    }\n\n    callback(null, false);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}