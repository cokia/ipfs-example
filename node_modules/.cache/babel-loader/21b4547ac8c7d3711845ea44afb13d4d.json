{"ast":null,"code":"'use strict';\n\nconst ieee754 = require('ieee754');\n\nconst Bignumber = require('bignumber.js');\n\nconst parser = require('./decoder.asm');\n\nconst utils = require('./utils');\n\nconst c = require('./constants');\n\nconst Simple = require('./simple');\n\nconst Tagged = require('./tagged');\n\nconst _require = require('iso-url'),\n      URL = _require.URL;\n/**\n * Transform binary cbor data into JavaScript objects.\n */\n\n\nclass Decoder {\n  /**\n   * @param {Object} [opts={}]\n   * @param {number} [opts.size=65536] - Size of the allocated heap.\n   */\n  constructor(opts) {\n    opts = opts || {};\n\n    if (!opts.size || opts.size < 0x10000) {\n      opts.size = 0x10000;\n    } else {\n      // Ensure the size is a power of 2\n      opts.size = utils.nextPowerOf2(opts.size);\n    } // Heap use to share the input with the parser\n\n\n    this._heap = new ArrayBuffer(opts.size);\n    this._heap8 = new Uint8Array(this._heap);\n    this._buffer = Buffer.from(this._heap);\n\n    this._reset(); // Known tags\n\n\n    this._knownTags = Object.assign({\n      0: val => new Date(val),\n      1: val => new Date(val * 1000),\n      2: val => utils.arrayBufferToBignumber(val),\n      3: val => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),\n      4: v => {\n        // const v = new Uint8Array(val)\n        return c.TEN.pow(v[0]).times(v[1]);\n      },\n      5: v => {\n        // const v = new Uint8Array(val)\n        return c.TWO.pow(v[0]).times(v[1]);\n      },\n      32: val => new URL(val),\n      35: val => new RegExp(val)\n    }, opts.tags); // Initialize asm based parser\n\n    this.parser = parser(global, {\n      log: console.log.bind(console),\n      pushInt: this.pushInt.bind(this),\n      pushInt32: this.pushInt32.bind(this),\n      pushInt32Neg: this.pushInt32Neg.bind(this),\n      pushInt64: this.pushInt64.bind(this),\n      pushInt64Neg: this.pushInt64Neg.bind(this),\n      pushFloat: this.pushFloat.bind(this),\n      pushFloatSingle: this.pushFloatSingle.bind(this),\n      pushFloatDouble: this.pushFloatDouble.bind(this),\n      pushTrue: this.pushTrue.bind(this),\n      pushFalse: this.pushFalse.bind(this),\n      pushUndefined: this.pushUndefined.bind(this),\n      pushNull: this.pushNull.bind(this),\n      pushInfinity: this.pushInfinity.bind(this),\n      pushInfinityNeg: this.pushInfinityNeg.bind(this),\n      pushNaN: this.pushNaN.bind(this),\n      pushNaNNeg: this.pushNaNNeg.bind(this),\n      pushArrayStart: this.pushArrayStart.bind(this),\n      pushArrayStartFixed: this.pushArrayStartFixed.bind(this),\n      pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),\n      pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),\n      pushObjectStart: this.pushObjectStart.bind(this),\n      pushObjectStartFixed: this.pushObjectStartFixed.bind(this),\n      pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),\n      pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),\n      pushByteString: this.pushByteString.bind(this),\n      pushByteStringStart: this.pushByteStringStart.bind(this),\n      pushUtf8String: this.pushUtf8String.bind(this),\n      pushUtf8StringStart: this.pushUtf8StringStart.bind(this),\n      pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),\n      pushTagUnassigned: this.pushTagUnassigned.bind(this),\n      pushTagStart: this.pushTagStart.bind(this),\n      pushTagStart4: this.pushTagStart4.bind(this),\n      pushTagStart8: this.pushTagStart8.bind(this),\n      pushBreak: this.pushBreak.bind(this)\n    }, this._heap);\n  }\n\n  get _depth() {\n    return this._parents.length;\n  }\n\n  get _currentParent() {\n    return this._parents[this._depth - 1];\n  }\n\n  get _ref() {\n    return this._currentParent.ref;\n  } // Finish the current parent\n\n\n  _closeParent() {\n    var p = this._parents.pop();\n\n    if (p.length > 0) {\n      throw new Error(\"Missing \".concat(p.length, \" elements\"));\n    }\n\n    switch (p.type) {\n      case c.PARENT.TAG:\n        this._push(this.createTag(p.ref[0], p.ref[1]));\n\n        break;\n\n      case c.PARENT.BYTE_STRING:\n        this._push(this.createByteString(p.ref, p.length));\n\n        break;\n\n      case c.PARENT.UTF8_STRING:\n        this._push(this.createUtf8String(p.ref, p.length));\n\n        break;\n\n      case c.PARENT.MAP:\n        if (p.values % 2 > 0) {\n          throw new Error('Odd number of elements in the map');\n        }\n\n        this._push(this.createMap(p.ref, p.length));\n\n        break;\n\n      case c.PARENT.OBJECT:\n        if (p.values % 2 > 0) {\n          throw new Error('Odd number of elements in the map');\n        }\n\n        this._push(this.createObject(p.ref, p.length));\n\n        break;\n\n      case c.PARENT.ARRAY:\n        this._push(this.createArray(p.ref, p.length));\n\n        break;\n\n      default:\n        break;\n    }\n\n    if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {\n      this._dec();\n    }\n  } // Reduce the expected length of the current parent by one\n\n\n  _dec() {\n    const p = this._currentParent; // The current parent does not know the epxected child length\n\n    if (p.length < 0) {\n      return;\n    }\n\n    p.length--; // All children were seen, we can close the current parent\n\n    if (p.length === 0) {\n      this._closeParent();\n    }\n  } // Push any value to the current parent\n\n\n  _push(val, hasChildren) {\n    const p = this._currentParent;\n    p.values++;\n\n    switch (p.type) {\n      case c.PARENT.ARRAY:\n      case c.PARENT.BYTE_STRING:\n      case c.PARENT.UTF8_STRING:\n        if (p.length > -1) {\n          this._ref[this._ref.length - p.length] = val;\n        } else {\n          this._ref.push(val);\n        }\n\n        this._dec();\n\n        break;\n\n      case c.PARENT.OBJECT:\n        if (p.tmpKey != null) {\n          this._ref[p.tmpKey] = val;\n          p.tmpKey = null;\n\n          this._dec();\n        } else {\n          p.tmpKey = val;\n\n          if (typeof p.tmpKey !== 'string') {\n            // too bad, convert to a Map\n            p.type = c.PARENT.MAP;\n            p.ref = utils.buildMap(p.ref);\n          }\n        }\n\n        break;\n\n      case c.PARENT.MAP:\n        if (p.tmpKey != null) {\n          this._ref.set(p.tmpKey, val);\n\n          p.tmpKey = null;\n\n          this._dec();\n        } else {\n          p.tmpKey = val;\n        }\n\n        break;\n\n      case c.PARENT.TAG:\n        this._ref.push(val);\n\n        if (!hasChildren) {\n          this._dec();\n        }\n\n        break;\n\n      default:\n        throw new Error('Unknown parent type');\n    }\n  } // Create a new parent in the parents list\n\n\n  _createParent(obj, type, len) {\n    this._parents[this._depth] = {\n      type: type,\n      length: len,\n      ref: obj,\n      values: 0,\n      tmpKey: null\n    };\n  } // Reset all state back to the beginning, also used for initiatlization\n\n\n  _reset() {\n    this._res = [];\n    this._parents = [{\n      type: c.PARENT.ARRAY,\n      length: -1,\n      ref: this._res,\n      values: 0,\n      tmpKey: null\n    }];\n  } // -- Interface to customize deoding behaviour\n\n\n  createTag(tagNumber, value) {\n    const typ = this._knownTags[tagNumber];\n\n    if (!typ) {\n      return new Tagged(tagNumber, value);\n    }\n\n    return typ(value);\n  }\n\n  createMap(obj, len) {\n    return obj;\n  }\n\n  createObject(obj, len) {\n    return obj;\n  }\n\n  createArray(arr, len) {\n    return arr;\n  }\n\n  createByteString(raw, len) {\n    return Buffer.concat(raw);\n  }\n\n  createByteStringFromHeap(start, end) {\n    if (start === end) {\n      return Buffer.alloc(0);\n    }\n\n    return Buffer.from(this._heap.slice(start, end));\n  }\n\n  createInt(val) {\n    return val;\n  }\n\n  createInt32(f, g) {\n    return utils.buildInt32(f, g);\n  }\n\n  createInt64(f1, f2, g1, g2) {\n    return utils.buildInt64(f1, f2, g1, g2);\n  }\n\n  createFloat(val) {\n    return val;\n  }\n\n  createFloatSingle(a, b, c, d) {\n    return ieee754.read([a, b, c, d], 0, false, 23, 4);\n  }\n\n  createFloatDouble(a, b, c, d, e, f, g, h) {\n    return ieee754.read([a, b, c, d, e, f, g, h], 0, false, 52, 8);\n  }\n\n  createInt32Neg(f, g) {\n    return -1 - utils.buildInt32(f, g);\n  }\n\n  createInt64Neg(f1, f2, g1, g2) {\n    const f = utils.buildInt32(f1, f2);\n    const g = utils.buildInt32(g1, g2);\n\n    if (f > c.MAX_SAFE_HIGH) {\n      return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g));\n    }\n\n    return -1 - (f * c.SHIFT32 + g);\n  }\n\n  createTrue() {\n    return true;\n  }\n\n  createFalse() {\n    return false;\n  }\n\n  createNull() {\n    return null;\n  }\n\n  createUndefined() {\n    return void 0;\n  }\n\n  createInfinity() {\n    return Infinity;\n  }\n\n  createInfinityNeg() {\n    return -Infinity;\n  }\n\n  createNaN() {\n    return NaN;\n  }\n\n  createNaNNeg() {\n    return -NaN;\n  }\n\n  createUtf8String(raw, len) {\n    return raw.join('');\n  }\n\n  createUtf8StringFromHeap(start, end) {\n    if (start === end) {\n      return '';\n    }\n\n    return this._buffer.toString('utf8', start, end);\n  }\n\n  createSimpleUnassigned(val) {\n    return new Simple(val);\n  } // -- Interface for decoder.asm.js\n\n\n  pushInt(val) {\n    this._push(this.createInt(val));\n  }\n\n  pushInt32(f, g) {\n    this._push(this.createInt32(f, g));\n  }\n\n  pushInt64(f1, f2, g1, g2) {\n    this._push(this.createInt64(f1, f2, g1, g2));\n  }\n\n  pushFloat(val) {\n    this._push(this.createFloat(val));\n  }\n\n  pushFloatSingle(a, b, c, d) {\n    this._push(this.createFloatSingle(a, b, c, d));\n  }\n\n  pushFloatDouble(a, b, c, d, e, f, g, h) {\n    this._push(this.createFloatDouble(a, b, c, d, e, f, g, h));\n  }\n\n  pushInt32Neg(f, g) {\n    this._push(this.createInt32Neg(f, g));\n  }\n\n  pushInt64Neg(f1, f2, g1, g2) {\n    this._push(this.createInt64Neg(f1, f2, g1, g2));\n  }\n\n  pushTrue() {\n    this._push(this.createTrue());\n  }\n\n  pushFalse() {\n    this._push(this.createFalse());\n  }\n\n  pushNull() {\n    this._push(this.createNull());\n  }\n\n  pushUndefined() {\n    this._push(this.createUndefined());\n  }\n\n  pushInfinity() {\n    this._push(this.createInfinity());\n  }\n\n  pushInfinityNeg() {\n    this._push(this.createInfinityNeg());\n  }\n\n  pushNaN() {\n    this._push(this.createNaN());\n  }\n\n  pushNaNNeg() {\n    this._push(this.createNaNNeg());\n  }\n\n  pushArrayStart() {\n    this._createParent([], c.PARENT.ARRAY, -1);\n  }\n\n  pushArrayStartFixed(len) {\n    this._createArrayStartFixed(len);\n  }\n\n  pushArrayStartFixed32(len1, len2) {\n    const len = utils.buildInt32(len1, len2);\n\n    this._createArrayStartFixed(len);\n  }\n\n  pushArrayStartFixed64(len1, len2, len3, len4) {\n    const len = utils.buildInt64(len1, len2, len3, len4);\n\n    this._createArrayStartFixed(len);\n  }\n\n  pushObjectStart() {\n    this._createObjectStartFixed(-1);\n  }\n\n  pushObjectStartFixed(len) {\n    this._createObjectStartFixed(len);\n  }\n\n  pushObjectStartFixed32(len1, len2) {\n    const len = utils.buildInt32(len1, len2);\n\n    this._createObjectStartFixed(len);\n  }\n\n  pushObjectStartFixed64(len1, len2, len3, len4) {\n    const len = utils.buildInt64(len1, len2, len3, len4);\n\n    this._createObjectStartFixed(len);\n  }\n\n  pushByteStringStart() {\n    this._parents[this._depth] = {\n      type: c.PARENT.BYTE_STRING,\n      length: -1,\n      ref: [],\n      values: 0,\n      tmpKey: null\n    };\n  }\n\n  pushByteString(start, end) {\n    this._push(this.createByteStringFromHeap(start, end));\n  }\n\n  pushUtf8StringStart() {\n    this._parents[this._depth] = {\n      type: c.PARENT.UTF8_STRING,\n      length: -1,\n      ref: [],\n      values: 0,\n      tmpKey: null\n    };\n  }\n\n  pushUtf8String(start, end) {\n    this._push(this.createUtf8StringFromHeap(start, end));\n  }\n\n  pushSimpleUnassigned(val) {\n    this._push(this.createSimpleUnassigned(val));\n  }\n\n  pushTagStart(tag) {\n    this._parents[this._depth] = {\n      type: c.PARENT.TAG,\n      length: 1,\n      ref: [tag]\n    };\n  }\n\n  pushTagStart4(f, g) {\n    this.pushTagStart(utils.buildInt32(f, g));\n  }\n\n  pushTagStart8(f1, f2, g1, g2) {\n    this.pushTagStart(utils.buildInt64(f1, f2, g1, g2));\n  }\n\n  pushTagUnassigned(tagNumber) {\n    this._push(this.createTag(tagNumber));\n  }\n\n  pushBreak() {\n    if (this._currentParent.length > -1) {\n      throw new Error('Unexpected break');\n    }\n\n    this._closeParent();\n  }\n\n  _createObjectStartFixed(len) {\n    if (len === 0) {\n      this._push(this.createObject({}));\n\n      return;\n    }\n\n    this._createParent({}, c.PARENT.OBJECT, len);\n  }\n\n  _createArrayStartFixed(len) {\n    if (len === 0) {\n      this._push(this.createArray([]));\n\n      return;\n    }\n\n    this._createParent(new Array(len), c.PARENT.ARRAY, len);\n  }\n\n  _decode(input) {\n    if (input.byteLength === 0) {\n      throw new Error('Input too short');\n    }\n\n    this._reset();\n\n    this._heap8.set(input);\n\n    const code = this.parser.parse(input.byteLength);\n\n    if (this._depth > 1) {\n      while (this._currentParent.length === 0) {\n        this._closeParent();\n      }\n\n      if (this._depth > 1) {\n        throw new Error('Undeterminated nesting');\n      }\n    }\n\n    if (code > 0) {\n      throw new Error('Failed to parse');\n    }\n\n    if (this._res.length === 0) {\n      throw new Error('No valid result');\n    }\n  } // -- Public Interface\n\n\n  decodeFirst(input) {\n    this._decode(input);\n\n    return this._res[0];\n  }\n\n  decodeAll(input) {\n    this._decode(input);\n\n    return this._res;\n  }\n  /**\n   * Decode the first cbor object.\n   *\n   * @param {Buffer|string} input\n   * @param {string} [enc='hex'] - Encoding used if a string is passed.\n   * @returns {*}\n   */\n\n\n  static decode(input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex');\n    }\n\n    const dec = new Decoder({\n      size: input.length\n    });\n    return dec.decodeFirst(input);\n  }\n  /**\n   * Decode all cbor objects.\n   *\n   * @param {Buffer|string} input\n   * @param {string} [enc='hex'] - Encoding used if a string is passed.\n   * @returns {Array<*>}\n   */\n\n\n  static decodeAll(input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex');\n    }\n\n    const dec = new Decoder({\n      size: input.length\n    });\n    return dec.decodeAll(input);\n  }\n\n}\n\nDecoder.decodeFirst = Decoder.decode;\nmodule.exports = Decoder;","map":null,"metadata":{},"sourceType":"script"}