{"ast":null,"code":"'use strict';\n\nconst Decoder = require('./decoder');\n\nconst utils = require('./utils');\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n */\n\n\nclass Diagnose extends Decoder {\n  createTag(tagNumber, value) {\n    return \"\".concat(tagNumber, \"(\").concat(value, \")\");\n  }\n\n  createInt(val) {\n    return super.createInt(val).toString();\n  }\n\n  createInt32(f, g) {\n    return super.createInt32(f, g).toString();\n  }\n\n  createInt64(f1, f2, g1, g2) {\n    return super.createInt64(f1, f2, g1, g2).toString();\n  }\n\n  createInt32Neg(f, g) {\n    return super.createInt32Neg(f, g).toString();\n  }\n\n  createInt64Neg(f1, f2, g1, g2) {\n    return super.createInt64Neg(f1, f2, g1, g2).toString();\n  }\n\n  createTrue() {\n    return 'true';\n  }\n\n  createFalse() {\n    return 'false';\n  }\n\n  createFloat(val) {\n    const fl = super.createFloat(val);\n\n    if (utils.isNegativeZero(val)) {\n      return '-0_1';\n    }\n\n    return \"\".concat(fl, \"_1\");\n  }\n\n  createFloatSingle(a, b, c, d) {\n    const fl = super.createFloatSingle(a, b, c, d);\n    return \"\".concat(fl, \"_2\");\n  }\n\n  createFloatDouble(a, b, c, d, e, f, g, h) {\n    const fl = super.createFloatDouble(a, b, c, d, e, f, g, h);\n    return \"\".concat(fl, \"_3\");\n  }\n\n  createByteString(raw, len) {\n    const val = raw.join(', ');\n\n    if (len === -1) {\n      return \"(_ \".concat(val, \")\");\n    }\n\n    return \"h'\".concat(val);\n  }\n\n  createByteStringFromHeap(start, end) {\n    const val = Buffer.from(super.createByteStringFromHeap(start, end)).toString('hex');\n    return \"h'\".concat(val, \"'\");\n  }\n\n  createInfinity() {\n    return 'Infinity_1';\n  }\n\n  createInfinityNeg() {\n    return '-Infinity_1';\n  }\n\n  createNaN() {\n    return 'NaN_1';\n  }\n\n  createNaNNeg() {\n    return '-NaN_1';\n  }\n\n  createNull() {\n    return 'null';\n  }\n\n  createUndefined() {\n    return 'undefined';\n  }\n\n  createSimpleUnassigned(val) {\n    return \"simple(\".concat(val, \")\");\n  }\n\n  createArray(arr, len) {\n    const val = super.createArray(arr, len);\n\n    if (len === -1) {\n      // indefinite\n      return \"[_ \".concat(val.join(', '), \"]\");\n    }\n\n    return \"[\".concat(val.join(', '), \"]\");\n  }\n\n  createMap(map, len) {\n    const val = super.createMap(map);\n    const list = Array.from(val.keys()).reduce(collectObject(val), '');\n\n    if (len === -1) {\n      return \"{_ \".concat(list, \"}\");\n    }\n\n    return \"{\".concat(list, \"}\");\n  }\n\n  createObject(obj, len) {\n    const val = super.createObject(obj);\n    const map = Object.keys(val).reduce(collectObject(val), '');\n\n    if (len === -1) {\n      return \"{_ \".concat(map, \"}\");\n    }\n\n    return \"{\".concat(map, \"}\");\n  }\n\n  createUtf8String(raw, len) {\n    const val = raw.join(', ');\n\n    if (len === -1) {\n      return \"(_ \".concat(val, \")\");\n    }\n\n    return \"\\\"\".concat(val, \"\\\"\");\n  }\n\n  createUtf8StringFromHeap(start, end) {\n    const val = Buffer.from(super.createUtf8StringFromHeap(start, end)).toString('utf8');\n    return \"\\\"\".concat(val, \"\\\"\");\n  }\n\n  static diagnose(input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex');\n    }\n\n    const dec = new Diagnose();\n    return dec.decodeFirst(input);\n  }\n\n}\n\nmodule.exports = Diagnose;\n\nfunction collectObject(val) {\n  return (acc, key) => {\n    if (acc) {\n      return \"\".concat(acc, \", \").concat(key, \": \").concat(val[key]);\n    }\n\n    return \"\".concat(key, \": \").concat(val[key]);\n  };\n}","map":null,"metadata":{},"sourceType":"script"}