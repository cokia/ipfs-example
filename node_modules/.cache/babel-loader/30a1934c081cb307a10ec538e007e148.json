{"ast":null,"code":"'use strict';\n\nconst promisify = require('promisify-es6');\n\nconst EventEmitter = require('events');\n\nconst eos = require('end-of-stream');\n\nconst isNode = require('detect-node');\n\nconst setImmediate = require('async/setImmediate');\n\nconst PubsubMessageStream = require('./utils/pubsub-message-stream');\n\nconst stringlistToArray = require('./utils/stringlist-to-array');\n\nconst moduleConfig = require('./utils/module-config');\n\nconst NotSupportedError = () => new Error('pubsub is currently not supported when run in the browser');\n/* Public API */\n\n\nmodule.exports = arg => {\n  const send = moduleConfig(arg);\n  /* Internal subscriptions state and functions */\n\n  const ps = new EventEmitter();\n  const subscriptions = {};\n  ps.id = Math.random();\n  return {\n    subscribe: (topic, handler, options, callback) => {\n      const defaultOptions = {\n        discover: false\n      };\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = defaultOptions;\n      }\n\n      if (!options) {\n        options = defaultOptions;\n      } // Throw an error if ran in the browsers\n\n\n      if (!isNode) {\n        if (!callback) {\n          return Promise.reject(NotSupportedError());\n        }\n\n        return setImmediate(() => callback(NotSupportedError()));\n      } // promisify doesn't work as we always pass a\n      // function as last argument (`handler`)\n\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          subscribe(topic, handler, options, err => {\n            if (err) {\n              return reject(err);\n            }\n\n            resolve();\n          });\n        });\n      }\n\n      subscribe(topic, handler, options, callback);\n    },\n    unsubscribe: (topic, handler, callback) => {\n      if (!isNode) {\n        if (!callback) {\n          return Promise.reject(NotSupportedError());\n        }\n\n        return setImmediate(() => callback(NotSupportedError()));\n      }\n\n      if (ps.listenerCount(topic) === 0 || !subscriptions[topic]) {\n        const err = new Error(\"Not subscribed to '\".concat(topic, \"'\"));\n\n        if (!callback) {\n          return Promise.reject(err);\n        }\n\n        return setImmediate(() => callback(err));\n      }\n\n      ps.removeListener(topic, handler); // Drop the request once we are actually done\n\n      if (ps.listenerCount(topic) === 0) {\n        if (!callback) {\n          return new Promise((resolve, reject) => {\n            // When the response stream has ended, resolve the promise\n            eos(subscriptions[topic].res, err => {\n              // FIXME: Artificial timeout needed to ensure unsubscribed\n              setTimeout(() => {\n                if (err) return reject(err);\n                resolve();\n              });\n            });\n            subscriptions[topic].req.abort();\n            subscriptions[topic] = null;\n          });\n        } // When the response stream has ended, call the callback\n\n\n        eos(subscriptions[topic].res, err => {\n          // FIXME: Artificial timeout needed to ensure unsubscribed\n          setTimeout(() => callback(err));\n        });\n        subscriptions[topic].req.abort();\n        subscriptions[topic] = null;\n        return;\n      }\n\n      if (!callback) {\n        return Promise.resolve();\n      }\n\n      setImmediate(() => callback());\n    },\n    publish: promisify((topic, data, callback) => {\n      if (!isNode) {\n        return callback(NotSupportedError());\n      }\n\n      if (!Buffer.isBuffer(data)) {\n        return callback(new Error('data must be a Buffer'));\n      }\n\n      const request = {\n        path: 'pubsub/pub',\n        args: [topic, data]\n      };\n      send(request, callback);\n    }),\n    ls: promisify(callback => {\n      if (!isNode) {\n        return callback(NotSupportedError());\n      }\n\n      const request = {\n        path: 'pubsub/ls'\n      };\n      send.andTransform(request, stringlistToArray, callback);\n    }),\n    peers: promisify((topic, callback) => {\n      if (!isNode) {\n        return callback(NotSupportedError());\n      }\n\n      const request = {\n        path: 'pubsub/peers',\n        args: [topic]\n      };\n      send.andTransform(request, stringlistToArray, callback);\n    }),\n\n    setMaxListeners(n) {\n      return ps.setMaxListeners(n);\n    }\n\n  };\n\n  function subscribe(topic, handler, options, callback) {\n    ps.on(topic, handler);\n\n    if (subscriptions[topic]) {\n      // TODO: should a callback error be returned?\n      return callback();\n    } // Request params\n\n\n    const request = {\n      path: 'pubsub/sub',\n      args: [topic],\n      qs: {\n        discover: options.discover\n      } // Start the request and transform the response\n      // stream to Pubsub messages stream\n\n    };\n    subscriptions[topic] = {};\n    subscriptions[topic].req = send.andTransform(request, PubsubMessageStream.from, (err, stream) => {\n      if (err) {\n        subscriptions[topic] = null;\n        ps.removeListener(topic, handler);\n        return callback(err);\n      }\n\n      subscriptions[topic].res = stream;\n      stream.on('data', msg => {\n        ps.emit(topic, msg);\n      });\n      stream.on('error', err => {\n        ps.emit('error', err);\n      });\n      eos(stream, err => {\n        if (err) {\n          ps.emit('error', err);\n        }\n\n        subscriptions[topic] = null;\n        ps.removeListener(topic, handler);\n      });\n      callback();\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}