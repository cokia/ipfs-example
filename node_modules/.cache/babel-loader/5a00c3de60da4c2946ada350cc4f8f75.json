{"ast":null,"code":"'use strict';\n\nvar BigInteger = require('jsbn').BigInteger;\n\nvar common = require('./common.js');\n\nvar padStart = require('lodash.padstart');\n\nvar repeat = require('lodash.repeat');\n\nvar sprintf = require('sprintf-js').sprintf;\n\nvar constants = require('./v4/constants.js');\n/**\n * Represents an IPv4 address\n * @class Address4\n * @param {string} address - An IPv4 address string\n */\n\n\nfunction Address4(address) {\n  this.valid = false;\n  this.address = address;\n  this.groups = constants.GROUPS;\n  this.v4 = true;\n  this.subnet = '/32';\n  this.subnetMask = 32;\n  var subnet = constants.RE_SUBNET_STRING.exec(address);\n\n  if (subnet) {\n    this.parsedSubnet = subnet[0].replace('/', '');\n    this.subnetMask = parseInt(this.parsedSubnet, 10);\n    this.subnet = '/' + this.subnetMask;\n\n    if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {\n      this.valid = false;\n      this.error = 'Invalid subnet mask.';\n      return;\n    }\n\n    address = address.replace(constants.RE_SUBNET_STRING, '');\n  }\n\n  this.addressMinusSuffix = address;\n  this.parsedAddress = this.parse(address);\n}\n/*\n * Parses a v4 address\n */\n\n\nAddress4.prototype.parse = function (address) {\n  var groups = address.split('.');\n\n  if (address.match(constants.RE_ADDRESS)) {\n    this.valid = true;\n  } else {\n    this.error = 'Invalid IPv4 address.';\n  }\n\n  return groups;\n};\n/**\n * Return true if the address is valid\n * @memberof Address4\n * @instance\n * @returns {Boolean}\n */\n\n\nAddress4.prototype.isValid = function () {\n  return this.valid;\n};\n/**\n * Returns the correct form of an address\n * @memberof Address4\n * @instance\n * @returns {String}\n */\n\n\nAddress4.prototype.correctForm = function () {\n  return this.parsedAddress.map(function (part) {\n    return parseInt(part, 10);\n  }).join('.');\n};\n/**\n * Returns true if the address is correct, false otherwise\n * @memberof Address4\n * @instance\n * @returns {Boolean}\n */\n\n\nAddress4.prototype.isCorrect = common.isCorrect(constants.BITS);\n/**\n * Converts a hex string to an IPv4 address object\n * @memberof Address4\n * @static\n * @param {string} hex - a hex string to convert\n * @returns {Address4}\n */\n\nAddress4.fromHex = function (hex) {\n  var padded = padStart(hex.replace(/:/g, ''), 8, '0');\n  var groups = [];\n  var i;\n\n  for (i = 0; i < 8; i += 2) {\n    var h = padded.slice(i, i + 2);\n    groups.push(parseInt(h, 16));\n  }\n\n  return new Address4(groups.join('.'));\n};\n/**\n * Converts an integer into a IPv4 address object\n * @memberof Address4\n * @static\n * @param {integer} integer - a number to convert\n * @returns {Address4}\n */\n\n\nAddress4.fromInteger = function (integer) {\n  return Address4.fromHex(integer.toString(16));\n};\n/**\n * Converts an IPv4 address object to a hex string\n * @memberof Address4\n * @instance\n * @returns {String}\n */\n\n\nAddress4.prototype.toHex = function () {\n  return this.parsedAddress.map(function (part) {\n    return sprintf('%02x', parseInt(part, 10));\n  }).join(':');\n};\n/**\n * Converts an IPv4 address object to an array of bytes\n * @memberof Address4\n * @instance\n * @returns {Array}\n */\n\n\nAddress4.prototype.toArray = function () {\n  return this.parsedAddress.map(function (part) {\n    return parseInt(part, 10);\n  });\n};\n/**\n * Converts an IPv4 address object to an IPv6 address group\n * @memberof Address4\n * @instance\n * @returns {String}\n */\n\n\nAddress4.prototype.toGroup6 = function () {\n  var output = [];\n  var i;\n\n  for (i = 0; i < constants.GROUPS; i += 2) {\n    var hex = sprintf('%02x%02x', parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));\n    output.push(sprintf('%x', parseInt(hex, 16)));\n  }\n\n  return output.join(':');\n};\n/**\n * Returns the address as a BigInteger\n * @memberof Address4\n * @instance\n * @returns {BigInteger}\n */\n\n\nAddress4.prototype.bigInteger = function () {\n  if (!this.valid) {\n    return null;\n  }\n\n  return new BigInteger(this.parsedAddress.map(function (n) {\n    return sprintf('%02x', parseInt(n, 10));\n  }).join(''), 16);\n};\n/**\n * Helper function getting start address.\n * @memberof Address4\n * @instance\n * @returns {BigInteger}\n */\n\n\nAddress4.prototype._startAddress = function () {\n  return new BigInteger(this.mask() + repeat(0, constants.BITS - this.subnetMask), 2);\n};\n/**\n * The first address in the range given by this address' subnet.\n * Often referred to as the Network Address.\n * @memberof Address4\n * @instance\n * @returns {Address4}\n */\n\n\nAddress4.prototype.startAddress = function () {\n  return Address4.fromBigInteger(this._startAddress());\n};\n/**\n * The first host address in the range given by this address's subnet ie\n * the first address after the Network Address\n * @memberof Address4\n * @instance\n * @returns {Address4}\n */\n\n\nAddress4.prototype.startAddressExclusive = function () {\n  var adjust = new BigInteger('1');\n  return Address4.fromBigInteger(this._startAddress().add(adjust));\n};\n/**\n * Helper function getting end address.\n * @memberof Address4\n * @instance\n * @returns {BigInteger}\n */\n\n\nAddress4.prototype._endAddress = function () {\n  return new BigInteger(this.mask() + repeat(1, constants.BITS - this.subnetMask), 2);\n};\n/**\n * The last address in the range given by this address' subnet\n * Often referred to as the Broadcast\n * @memberof Address4\n * @instance\n * @returns {Address4}\n */\n\n\nAddress4.prototype.endAddress = function () {\n  return Address4.fromBigInteger(this._endAddress());\n};\n/**\n * The last host address in the range given by this address's subnet ie\n * the last address prior to the Broadcast Address\n * @memberof Address4\n * @instance\n * @returns {Address4}\n */\n\n\nAddress4.prototype.endAddressExclusive = function () {\n  var adjust = new BigInteger('1');\n  return Address4.fromBigInteger(this._endAddress().subtract(adjust));\n};\n/**\n * Converts a BigInteger to a v4 address object\n * @memberof Address4\n * @static\n * @param {BigInteger} bigInteger - a BigInteger to convert\n * @returns {Address4}\n */\n\n\nAddress4.fromBigInteger = function (bigInteger) {\n  return Address4.fromInteger(parseInt(bigInteger.toString(), 10));\n};\n/**\n * Returns the first n bits of the address, defaulting to the\n * subnet mask\n * @memberof Address4\n * @instance\n * @returns {String}\n */\n\n\nAddress4.prototype.mask = function (optionalMask) {\n  if (optionalMask === undefined) {\n    optionalMask = this.subnetMask;\n  }\n\n  return this.getBitsBase2(0, optionalMask);\n};\n/**\n * Returns the bits in the given range as a base-2 string\n * @memberof Address4\n * @instance\n * @returns {string}\n */\n\n\nAddress4.prototype.getBitsBase2 = function (start, end) {\n  return this.binaryZeroPad().slice(start, end);\n};\n/**\n * Returns true if the given address is in the subnet of the current address\n * @memberof Address4\n * @instance\n * @returns {boolean}\n */\n\n\nAddress4.prototype.isInSubnet = common.isInSubnet;\n/**\n * Returns a zero-padded base-2 string representation of the address\n * @memberof Address4\n * @instance\n * @returns {string}\n */\n\nAddress4.prototype.binaryZeroPad = function () {\n  return padStart(this.bigInteger().toString(2), constants.BITS, '0');\n};\n\nmodule.exports = Address4;","map":null,"metadata":{},"sourceType":"script"}