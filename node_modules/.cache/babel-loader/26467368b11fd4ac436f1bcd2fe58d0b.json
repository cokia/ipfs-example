{"ast":null,"code":"'use strict';\n\nconst protons = require('protons');\n\nconst pb = protons(require('./unixfs.proto')); // encode/decode\n\nconst unixfsData = pb.Data; // const unixfsMetadata = pb.MetaData // encode/decode\n\nconst types = ['raw', 'directory', 'file', 'metadata', 'symlink', 'hamt-sharded-directory'];\nconst dirTypes = ['directory', 'hamt-sharded-directory'];\n\nfunction Data(type, data) {\n  if (!(this instanceof Data)) {\n    return new Data(type, data);\n  }\n\n  if (types.indexOf(type) === -1) {\n    throw new Error('Type: ' + type + ' is not valid');\n  }\n\n  this.type = type;\n  this.data = data;\n  this.blockSizes = [];\n\n  this.addBlockSize = size => {\n    this.blockSizes.push(size);\n  };\n\n  this.removeBlockSize = index => {\n    this.blockSizes.splice(index, 1);\n  }; // data.length + blockSizes\n\n\n  this.fileSize = () => {\n    if (dirTypes.indexOf(this.type) >= 0) {\n      // dirs don't have file size\n      return undefined;\n    }\n\n    let sum = 0;\n    this.blockSizes.forEach(size => {\n      sum += size;\n    });\n\n    if (data) {\n      sum += data.length;\n    }\n\n    return sum;\n  }; // encode to protobuf\n\n\n  this.marshal = () => {\n    let type;\n\n    switch (this.type) {\n      case 'raw':\n        type = unixfsData.DataType.Raw;\n        break;\n\n      case 'directory':\n        type = unixfsData.DataType.Directory;\n        break;\n\n      case 'file':\n        type = unixfsData.DataType.File;\n        break;\n\n      case 'metadata':\n        type = unixfsData.DataType.Metadata;\n        break;\n\n      case 'symlink':\n        type = unixfsData.DataType.Symlink;\n        break;\n\n      case 'hamt-sharded-directory':\n        type = unixfsData.DataType.HAMTShard;\n        break;\n\n      default:\n        throw new Error(\"Unkown type: \\\"\".concat(this.type, \"\\\"\"));\n    }\n\n    let fileSize = this.fileSize();\n    let data = this.data;\n\n    if (!this.data || !this.data.length) {\n      data = undefined;\n    }\n\n    let blockSizes = this.blockSizes;\n\n    if (!this.blockSizes || !this.blockSizes.length) {\n      blockSizes = undefined;\n    }\n\n    return unixfsData.encode({\n      Type: type,\n      Data: data,\n      filesize: fileSize,\n      blocksizes: blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout\n    });\n  };\n} // decode from protobuf https://github.com/ipfs/go-ipfs/blob/master/unixfs/format.go#L24\n\n\nData.unmarshal = marsheled => {\n  const decoded = unixfsData.decode(marsheled);\n\n  if (!decoded.Data) {\n    decoded.Data = undefined;\n  }\n\n  const obj = new Data(types[decoded.Type], decoded.Data);\n  obj.blockSizes = decoded.blocksizes;\n  return obj;\n};\n\nexports = module.exports = Data;","map":null,"metadata":{},"sourceType":"script"}