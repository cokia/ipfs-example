{"ast":null,"code":"'use strict';\n\nconst util = require('./util');\n\nconst traverse = require('traverse');\n\nconst CID = require('cids');\n\nexports = module.exports;\nexports.multicodec = 'dag-cbor';\nexports.defaultHashAlg = 'sha2-256';\n/*\n * resolve: receives a path and a binary blob and returns the value on path,\n * throw if not possible. `binaryBlob` is CBOR encoded data.\n */\n\nexports.resolve = (binaryBlob, path, callback) => {\n  if (typeof path === 'function') {\n    callback = path;\n    path = undefined;\n  }\n\n  util.deserialize(binaryBlob, (err, node) => {\n    if (err) {\n      return callback(err);\n    } // root\n\n\n    if (!path || path === '/') {\n      return callback(null, {\n        value: node,\n        remainderPath: ''\n      });\n    } // within scope\n\n\n    const parts = path.split('/');\n    const val = traverse(node).get(parts);\n\n    if (val !== undefined) {\n      return callback(null, {\n        value: val,\n        remainderPath: ''\n      });\n    } // out of scope\n\n\n    let value;\n    const len = parts.length;\n\n    for (let i = 0; i < len; i++) {\n      const partialPath = parts.shift();\n\n      if (Array.isArray(node) && !Buffer.isBuffer(node)) {\n        value = node[Number(partialPath)];\n      }\n\n      if (node[partialPath]) {\n        value = node[partialPath];\n      } else {\n        // can't traverse more\n        if (!value) {\n          return callback(new Error('path not available at root'));\n        } else {\n          parts.unshift(partialPath);\n          return callback(null, {\n            value: value,\n            remainderPath: parts.join('/')\n          });\n        }\n      }\n\n      node = value;\n    }\n  });\n};\n\nfunction flattenObject(obj, delimiter) {\n  delimiter = delimiter || '/';\n\n  if (Object.keys(obj).length === 0) {\n    return [];\n  }\n\n  return traverse(obj).reduce(function (acc, x) {\n    if (CID.isCID(x)) {\n      this.update(undefined);\n    }\n\n    const path = this.path.join(delimiter);\n\n    if (path !== '') {\n      acc.push({\n        path: path,\n        value: x\n      });\n    }\n\n    return acc;\n  }, []);\n}\n/*\n * tree: returns a flattened array with paths: values of the project. options\n * are option (i.e. nestness)\n */\n\n\nexports.tree = (binaryBlob, options, callback) => {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  options = options || {};\n  util.deserialize(binaryBlob, (err, node) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const flat = flattenObject(node);\n    const paths = flat.map(el => el.path);\n    callback(null, paths);\n  });\n};\n\nexports.isLink = (binaryBlob, path, callback) => {\n  exports.resolve(binaryBlob, path, (err, result) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (result.remainderPath.length > 0) {\n      return callback(new Error('path out of scope'));\n    }\n\n    if (CID.isCID(result.value)) {\n      callback(null, result.value);\n    } else {\n      callback(null, false);\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}