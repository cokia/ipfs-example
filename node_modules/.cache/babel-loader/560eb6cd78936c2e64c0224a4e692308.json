{"ast":null,"code":"'use strict';\n\nconst base58 = require('bs58');\n\nconst multihash = require('multihashes');\n\nconst multibase = require('multibase');\n\nconst CID = require('cids');\n\nconst urlPattern = /^https?:\\/\\/[^/]+\\/(ip(f|n)s)\\/((\\w+).*)/;\nconst pathPattern = /^\\/(ip(f|n)s)\\/((\\w+).*)/;\nconst defaultProtocolMatch = 1;\nconst defaultHashMath = 4;\nconst fqdnPattern = /^https?:\\/\\/([^/]+)\\.(ip(?:f|n)s)\\.[^/]+/;\nconst fqdnHashMatch = 1;\nconst fqdnProtocolMatch = 2;\n\nfunction isMultihash(hash) {\n  const formatted = convertToString(hash);\n\n  try {\n    const buffer = Buffer.from(base58.decode(formatted));\n    multihash.decode(buffer);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isMultibase(hash) {\n  try {\n    return multibase.isEncoded(hash);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isCID(hash) {\n  try {\n    return CID.isCID(new CID(hash));\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n  const formatted = convertToString(input);\n\n  if (!formatted) {\n    return false;\n  }\n\n  const match = formatted.match(pattern);\n\n  if (!match) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false;\n  }\n\n  let hash = match[hashMatch];\n\n  if (hash && pattern === fqdnPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    hash = hash.toLowerCase();\n  }\n\n  return isCID(hash);\n}\n\nfunction isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch) {\n  const formatted = convertToString(input);\n\n  if (!formatted) {\n    return false;\n  }\n\n  const match = formatted.match(pattern);\n\n  if (!match) {\n    return false;\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false;\n  }\n\n  if (hashMatch && pattern === fqdnPattern) {\n    let hash = match[hashMatch]; // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n\n    hash = hash.toLowerCase();\n    return isCID(hash);\n  }\n\n  return true;\n}\n\nfunction convertToString(input) {\n  if (Buffer.isBuffer(input)) {\n    return base58.encode(input);\n  }\n\n  if (typeof input === 'string') {\n    return input;\n  }\n\n  return false;\n}\n\nconst ipfsSubdomain = url => isIpfs(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch);\n\nconst ipnsSubdomain = url => isIpns(url, fqdnPattern, fqdnProtocolMatch, fqdnHashMatch);\n\nmodule.exports = {\n  multihash: isMultihash,\n  cid: isCID,\n  base32cid: cid => isMultibase(cid) === 'base32' && isCID(cid),\n  ipfsSubdomain: ipfsSubdomain,\n  ipnsSubdomain: ipnsSubdomain,\n  subdomain: url => ipfsSubdomain(url) || ipnsSubdomain(url),\n  subdomainPattern: fqdnPattern,\n  ipfsUrl: url => isIpfs(url, urlPattern),\n  ipnsUrl: url => isIpns(url, urlPattern),\n  url: url => isIpfs(url, urlPattern) || isIpns(url, urlPattern),\n  urlPattern: urlPattern,\n  ipfsPath: path => isIpfs(path, pathPattern),\n  ipnsPath: path => isIpns(path, pathPattern),\n  path: path => isIpfs(path, pathPattern) || isIpns(path, pathPattern),\n  pathPattern: pathPattern,\n  urlOrPath: x => isIpfs(x, urlPattern) || isIpns(x, urlPattern) || isIpfs(x, pathPattern) || isIpns(x, pathPattern)\n};","map":null,"metadata":{},"sourceType":"script"}