{"ast":null,"code":"'use strict';\n\nconst whilst = require('async/whilst');\n\nconst hmac = require('../hmac');\n\nconst cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  } // Generates a set of keys for each party by stretching the shared key.\n  // (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n\n};\n\nmodule.exports = (cipherType, hash, secret, callback) => {\n  const cipher = cipherMap[cipherType];\n\n  if (!cipher) {\n    return callback(new Error('unkown cipherType passed'));\n  }\n\n  if (!hash) {\n    return callback(new Error('unkown hashType passed'));\n  }\n\n  const cipherKeySize = cipher.keySize;\n  const ivSize = cipher.ivSize;\n  const hmacKeySize = 20;\n  const seed = Buffer.from('key expansion');\n  const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n  hmac.create(hash, secret, (err, m) => {\n    if (err) {\n      return callback(err);\n    }\n\n    m.digest(seed, (err, a) => {\n      if (err) {\n        return callback(err);\n      }\n\n      let result = [];\n      let j = 0;\n      whilst(() => j < resultLength, stretch, finish);\n\n      function stretch(cb) {\n        m.digest(Buffer.concat([a, seed]), (err, b) => {\n          if (err) {\n            return cb(err);\n          }\n\n          let todo = b.length;\n\n          if (j + todo > resultLength) {\n            todo = resultLength - j;\n          }\n\n          result.push(b);\n          j += todo;\n          m.digest(a, (err, _a) => {\n            if (err) {\n              return cb(err);\n            }\n\n            a = _a;\n            cb();\n          });\n        });\n      }\n\n      function finish(err) {\n        if (err) {\n          return callback(err);\n        }\n\n        const half = resultLength / 2;\n        const resultBuffer = Buffer.concat(result);\n        const r1 = resultBuffer.slice(0, half);\n        const r2 = resultBuffer.slice(half, resultLength);\n\n        const createKey = res => ({\n          iv: res.slice(0, ivSize),\n          cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n          macKey: res.slice(ivSize + cipherKeySize)\n        });\n\n        callback(null, {\n          k1: createKey(r1),\n          k2: createKey(r2)\n        });\n      }\n    });\n  });\n};","map":null,"metadata":{},"sourceType":"script"}