{"ast":null,"code":"'use strict';\n\nconst Duplex = require('stream').Duplex;\n\nconst eachSeries = require('async/eachSeries');\n\nconst isStream = require('is-stream');\n\nconst once = require('once');\n\nconst prepareFile = require('./prepare-file');\n\nconst Multipart = require('./multipart');\n\nfunction headers(file) {\n  const name = file.path ? encodeURIComponent(file.path) : '';\n  const header = {\n    'Content-Disposition': \"file; filename=\\\"\".concat(name, \"\\\"\")\n  };\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory';\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink';\n  } else {\n    header['Content-Type'] = 'application/octet-stream';\n  }\n\n  return header;\n}\n\nmodule.exports = (send, path) => {\n  return options => {\n    let request;\n    let ended = false;\n    let writing = false;\n    options = options ? Object.assign({}, options, options.qs) : {};\n    const multipart = new Multipart();\n    const retStream = new Duplex({\n      objectMode: true\n    });\n\n    retStream._read = n => {};\n\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next);\n\n      try {\n        const files = prepareFile(file, options).map(file => Object.assign({\n          headers: headers(file)\n        }, file));\n        writing = true;\n        eachSeries(files, (file, cb) => multipart.write(file, enc, cb), err => {\n          writing = false;\n\n          if (err) {\n            return next(err);\n          }\n\n          if (ended) {\n            multipart.end();\n          }\n\n          next();\n        });\n      } catch (err) {\n        next(err);\n      }\n    };\n\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true;\n\n        if (!writing) {\n          multipart.end();\n        }\n      }\n    });\n    const qs = options.qs || {};\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion');\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves');\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash');\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory');\n    qs.hash = propOrProp(options, 'hash', 'hashAlg');\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    };\n    multipart.on('error', err => {\n      retStream.emit('error', err);\n    });\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err);\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null); // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response);\n        retStream.push(null);\n        return;\n      }\n\n      response.on('error', err => retStream.emit('error', err));\n\n      if (options.converter) {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n        });\n        const Converter = options.converter;\n        const convertedResponse = new Converter();\n        convertedResponse.once('end', () => retStream.push(null));\n        convertedResponse.on('data', d => retStream.push(d));\n        response.pipe(convertedResponse);\n      } else {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n\n          retStream.push(d);\n        });\n        response.once('end', () => retStream.push(null));\n      }\n    }); // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n\n    request.on('drain', () => multipart.emit('drain'));\n    multipart.pipe(request);\n    return retStream;\n  };\n};\n\nfunction propOrProp(source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1];\n  } else if (prop2 in source) {\n    return source[prop2];\n  }\n}","map":null,"metadata":{},"sourceType":"script"}